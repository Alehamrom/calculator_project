package parser

import (
	"errors"
	"fmt"
	"strconv"
	"strings"
	"unicode"

	localModels "calculator_project/internal/models"
	"github.com/google/uuid"
)

// NodeType представляет тип узла в разобранном выражении.
type NodeType int

const (
	NodeTypeNumber   NodeType = iota // Узел представляет число
	NodeTypeOperator                 // Узел представляет оператор
)

type Node struct {
	Type  NodeType // Тип узла (число или оператор)
	Value string   // Значение узла (строка числа или оператор)
	Left  *Node    // Левый потомок (для операторов)
	Right *Node    // Правый потомок (для операторов)
}

// ParserState хранит состояние парсера во время разбора.
type ParserState struct {
	Input string
	Pos   int
}

// NewParser создает новый экземпляр ParserState.
func NewParser(expression string) *ParserState {
	return &ParserState{Input: strings.TrimSpace(expression), Pos: 0}
}

// ParseExpression парсит выражение и возвращает корневой узел разобранного дерева.
// Это основная функция парсинга.
// internal/parser/parser.go

// ... (остальные импорты и определения структур NodeType, Node, ParserState, NewParser) ...

// ParseExpression парсит выражение согласно грамматике Expression ::= Term { ('+' | '-') Term }.
// Возвращает корневой узел разобранной части выражения или ошибку.
// Эта функция предназначена для парсинга как всего выражения, так и выражений в скобках.
// !!! ВАЖНО: Эта функция парсит только часть выражения до первого символа, который не является Term или оператором +/-.
// Финальная проверка на необработанные символы должна быть выполнена ВЫШЕ, в коде, который вызвал эту функцию (например, в CalculateHandler).
func (p *ParserState) ParseExpression() (*Node, error) {
	// Начинаем парсинг с поиска Терма (с более высоким приоритетом: *, /)
	node, err := p.parseTerm()
	if err != nil {
		// Если при парсинге первого терма произошла ошибка, возвращаем ее.
		return nil, err
	}

	// Цикл для обработки операторов сложения (+) и вычитания (-)
	// Эти операторы имеют более низкий приоритет, чем * и /,
	// поэтому они обрабатываются на этом уровне (Expression).
	for {
		p.SkipSpaces() // Пропускаем пробелы перед следующим потенциальным оператором

		// Проверяем, является ли следующий символ оператором '+' или '-'
		if p.Pos < len(p.Input) && (p.Input[p.Pos] == '+' || p.Input[p.Pos] == '-') {
			operator := string(p.Input[p.Pos]) // Запоминаем оператор
			p.Pos++                            // Переходим за оператор, потребляя его

			// Парсим следующий Терм (правый операнд для текущего оператора + или -)
			rightNode, err := p.parseTerm()
			if err != nil {
				// Если при парсинге правого терма произошла ошибка, возвращаем ее.
				// (Например, если после '+' или '-' нет корректного терма)
				return nil, err
			}

			// Создаем новый узел для оператора (+ или -).
			// Левым потомком становится узел (или поддерево), который мы уже распарсили до текущего оператора.
			// Правым потомком становится только что распарсенный Терм.
			// Таким образом, мы строим дерево в соответствии с левой ассоциативностью и приоритетом.
			newNode := &Node{
				Type:  NodeTypeOperator,
				Value: operator,
				Left:  node,      // Предыдущий узел/поддерево становится левым потомком
				Right: rightNode, // Новый Терм становится правым потомком
			}
			node = newNode // Обновляем текущий корневой узел выражения
		} else {
			// Если текущий символ не является оператором '+' или '-',
			// значит, мы дошли до конца части выражения, обрабатываемой на этом уровне.
			// Парсинг выражения (или его части) завершен.
			break // Выходим из цикла
		}
	}

	// !!! ВАЖНО: ЗДЕСЬ НЕТ ПРОВЕРКИ p.Pos < len(p.Input) !!!
	// Эту проверку нужно делать ТОЛЬКО ОДИН РАЗ в CalculateHandler после ПЕРВОГО вызова ParseExpression.
	// Если этот вызов ParseExpression был рекурсивным (для парсинг2 + 3а выражения в скобках),
	// его "конец" (где находится p.Pos) не совпадает с концом всей исходной строки.

	// Возвращаем корневой узел разобранного выражения (или его части).
	// Возвращаем nil ошибку, так как до этой точки мы дошли без ошибок парсинга.
	return node, nil // Возвращаем успешно построенный узел и nil ошибку
}

// ... (Функции parseTerm, parseFactor, parseNumber, SkipSpaces, match, NodeToTasks должны быть такими же, как я приводил в Шаге 105) ...
// Убедись, что в parseFactor есть потребление закрывающей скобки `)`.
// Убедись, что в parseTerm есть цикл для `*` и `/`.
// Убедись, что в parseNumber правильно парсятся числа.
// Убедись, что NodeToTasks принимает *[]localModels.CalculationTask.

// parseTerm парсит термы (множители и делители) в выражении.
func (p *ParserState) parseTerm() (*Node, error) {
	// Начинаем парсинг с поиска Фактора (числа или выражения в скобках)
	node, err := p.parseFactor()
	if err != nil {
		// Если при парсинге первого Фактора произошла ошибка, возвращаем ее.
		return nil, err
	}

	// Цикл для обработки операторов умножения (*) и деления (/)
	// Эти операторы имеют более высокий приоритет, чем + и -,
	// поэтому они обрабатываются на этом уровне (Term).
	for {
		p.SkipSpaces() // Пропускаем пробелы перед потенциальным оператором

		// Проверяем, является ли следующий символ оператором '*' или '/'
		if p.Pos < len(p.Input) && (p.Input[p.Pos] == '*' || p.Input[p.Pos] == '/') {
			operator := string(p.Input[p.Pos]) // Запоминаем оператор
			p.Pos++                            // Переходим за оператор, потребляя его

			// Парсим следующий Фактор (правый операнд для текущего оператора * или /)
			rightNode, err := p.parseFactor()
			if err != nil {
				// Если при парсинге Фактора справа от оператора произошла ошибка, возвращаем ее.
				return nil, err
			}

			// Создаем новый узел для оператора (* или /).
			// Левым потомком становится узел (или поддерево), который мы уже распарсили до текущего оператора.
			// Правым потомком становится Фактор, который мы только что распарсили после оператора.
			// Это автоматически строит дерево с правильной левой ассоциативностью: (a * b) * c
			newNode := &Node{
				Type:  NodeTypeOperator,
				Value: operator,
				Left:  node,      // Предыдущий узел/поддерево становится левым потомком
				Right: rightNode, // Новый Фактор становится правым потомком
			}
			node = newNode // Обновляем текущий корневой узел Терма
		} else {
			// Если текущий символ не является оператором '*' или '/',
			// значит, мы дошли до конца части выражения, обрабатываемой на этом уровне.
			// Парсинг этого терма завершен.
			break // Выходим из цикла
		}
	}

	// Возвращаем корневой узел разобранного терма (Фактор или несколько Факторов, соединенных */*).
	// Возвращаем nil ошибку, так как до этой точки мы дошли без ошибок парсинга.
	return node, nil // Возвращаем успешно построенный узел и nil ошибку
}

// parseFactor парсит факторы (числа или выражения в скобках).
func (p *ParserState) parseFactor() (*Node, error) {
	p.SkipSpaces() // Пропускаем пробелы перед потенциальным Фактором

	// Проверяем, начинается ли Фактор со скобки '('
	if p.Pos < len(p.Input) && p.Input[p.Pos] == '(' {
		p.Pos++ // Потребляем '('

		// Рекурсивно парсим выражение внутри скобок
		node, err := p.ParseExpression()
		if err != nil {
			// Если при парсинге вложенного выражения ошибка, пробрасываем ее дальше
			return nil, err
		}

		p.SkipSpaces() // Пропускаем пробелы перед закрывающей скобкой ')'

		// Ожидаем закрывающую скобку ')'
		if p.Pos >= len(p.Input) || p.Input[p.Pos] != ')' {
			return nil, errors.New("ожидалась закрывающая скобка")
		}
		p.Pos++ // Потребляем ')'

		// *** Строгая проверка после парсинга (Expression) ***
		// После того как мы успешно распарсили "(Выражение)", следующим символом
		// (после опциональных пробелов) ОБЯЗАТЕЛЬНО должен быть оператор (+, -, *, /)
		// или конец строки. Если это что-то другое (например, еще одна ')', или буква), это ошибка.
		p.SkipSpaces()            // Пропускаем пробелы после ')'. p.Pos теперь стоит ПЕРЕД символом после скобок.
		if p.Pos < len(p.Input) { // Если строка не закончилась...
			nextChar := p.Input[p.Pos]
			// Проверяем, не является ли следующий символ оператором
			if nextChar != '+' && nextChar != '-' && nextChar != '*' && nextChar != '/' {
				// Если это не оператор, то это неожиданный символ в данном контексте.
				// Например, в "(2+3))" после первой ")" идет вторая ")". В "(2+3)abc" после ")" идет "a".
				// Это ошибка синтаксиса после закрывающей скобки фактора.
				return nil, fmt.Errorf("неожиданный символ '%c' после выражения в скобках на позиции %d", nextChar, p.Pos)
			}
			// Если это оператор, он будет обработан внешними циклами в parseTerm или ParseExpression.
			// Если строка закончилась, проверка на конец всей строки произойдет в CalculateHandler.
		}

		return node, nil // Возвращаем узел вложенного выражения как фактор
	}

	// Если не скобка, парсим число
	numNode, err := p.parseNumber()
	if err != nil {
		// Если при парсинге числа ошибка, пробрасываем ее
		return nil, err
	}

	// *** Строгая проверка после парсинга числа ***
	// После того как мы успешно распарсили число, следующим символом
	// (после опциональных пробелов) ОБЯЗАТЕЛЬНО должен быть оператор (+, -, *, /)
	// или закрывающая скобка ')', или конец строки. Если это что-то другое (например, буква, открывающая скобка), это ошибка.
	p.SkipSpaces()            // Пропускаем пробелы после числа. p.Pos теперь стоит ПЕРЕД символом после числа.
	if p.Pos < len(p.Input) { // Если строка не закончилась...
		nextChar := p.Input[p.Pos]
		// Проверяем, не является ли следующий символ оператором И не является ли он закрывающей скобкой
		if nextChar != '+' && nextChar != '-' && nextChar != '*' && nextChar != '/' && nextChar != ')' {
			// Если это не оператор и не закрывающая скобка, то это неожиданный символ после числа.
			// Например, в "2(3+4)" после "2" идет "(". В "2a" после "2" идет "a".
			// Это ошибка синтаксиса после числа.
			return nil, fmt.Errorf("неожиданный символ '%c' после числа на позиции %d", nextChar, p.Pos)
		}
		// Если это оператор или ')', он будет обработан внешними циклами или проверкой в parseFactor.
		// Если строка закончилась, финальная проверка в CalculateHandler обрабатывает это.
	}

	return numNode, nil // Возвращаем узел числа как фактор
}

// parseNumber парсит числовое значение.
func (p *ParserState) parseNumber() (*Node, error) {
	p.SkipSpaces() // Пропускаем пробелы перед числом

	start := p.Pos // Запоминаем начальную позицию числа

	// Потребляем опциональный знак '+' или '-'
	if p.Pos < len(p.Input) && (p.Input[p.Pos] == '+' || p.Input[p.Pos] == '-') {
		p.Pos++
	}

	tempPos := p.Pos // Временная позиция для проверки наличия цифр после знака
	// Потребляем цифры и, возможно, одну десятичную точку
	for tempPos < len(p.Input) && (unicode.IsDigit(rune(p.Input[tempPos])) || p.Input[tempPos] == '.') {
		tempPos++
	}

	// Если позиция не продвинулась после знака (или с начальной позиции, если знака не было),
	// значит, после знака не было цифр/точки, или вообще ничего не было на месте числа.
	if tempPos == p.Pos { // Не продвинулись после знака (или с начала)
		if p.Pos > start { // Если мы потребили знак, но после него ничего нет
			return nil, errors.New("некорректное число: только знак без цифр")
		}
		// Если мы не потребили даже знак, и не продвинулись, значит, здесь не число.
		return nil, errors.New("ожидалось число")
	}
	p.Pos = tempPos // Обновляем реальную позицию парсера после потребления цифр/точки

	numberStr := p.Input[start:p.Pos] // Извлекаем строку числа

	// Используем ParseFloat для финальной валидации формата числа.
	if _, err := strconv.ParseFloat(numberStr, 64); err != nil {
		return nil, fmt.Errorf("некорректный формат числа: %s", numberStr)
	}

	// !!! Важно: Здесь мы НЕ проверяем, что идет после числа.
	// Эту проверку делает вызывающая функция parseFactor.

	return &Node{Type: NodeTypeNumber, Value: numberStr}, nil // Возвращаем узел числа
}

// skipSpaces пропускает пробелы.
func (p *ParserState) SkipSpaces() {
	for p.Pos < len(p.Input) && unicode.IsSpace(rune(p.Input[p.Pos])) {
		p.Pos++
	}
}

// match проверяет, совпадает ли текущий символ с ожидаемым.
func (p *ParserState) match(ch byte) bool {
	return p.Pos < len(p.Input) && p.Input[p.Pos] == ch
}

// --- Функция для обхода дерева и создания задач ---

// NodeToTasks рекурсивно обходит дерево узлов выражения и формирует список задач.
// Возвращает список задач и ID узла (или значение), представляющего результат текущего поддерева.
// Для чисел возвращает само число как "результат", для операторов возвращает ID задачи.
func NodeToTasks(node *Node, tasks *[]localModels.CalculationTask) (string, error) {
	if node == nil {
		return "", errors.New("обход дерева: обнаружен nil узел")
	}

	if node.Type == NodeTypeNumber {
		// Если узел - число, его "результат" - само число (переданное как строка).
		// Для агента это будет просто операнд.
		return node.Value, nil
	}

	if node.Type == NodeTypeOperator {
		// Если узел - оператор, сначала рекурсивно обрабатываем его потомков.
		// Результаты потомков станут аргументами для текущей задачи.
		// Arg1Result и Arg2Result будут либо строкой числа, либо ID задачи, которая вычисляет этот аргумент.
		arg1Result, err := NodeToTasks(node.Left, tasks)
		if err != nil {
			return "", fmt.Errorf("обход дерева: ошибка при обработке левого потомка: %w", err)
		}
		arg2Result, err := NodeToTasks(node.Right, tasks)
		if err != nil {
			return "", fmt.Errorf("обход дерева: ошибка при обработке правого потомка: %w", err)
		}

		// Создаем задачу для текущей операции.
		taskID := uuid.New().String() // Генерируем уникальный ID для этой задачи

		newTask := localModels.CalculationTask{
			ID:        taskID,
			Operation: node.Value, // Оператор (+, -, *, /)
			Arg1:      arg1Result, // Результат левого потомка (число или ID задачи)
			Arg2:      arg2Result, // Результат правого потомка (число или ID задачи)
			Status:    "Pending",  // Начальный статус задачи
			// ExpressionID будет заполнен позже при сохранении
		}
		*tasks = append(*tasks, newTask) // Добавляем сгенерированную задачу в список задач

		// Результат этой задачи - это ее собственный ID.
		return taskID, nil
	}

	return "", errors.New("обход дерева: необработанный тип узла")
}

/*
func IsTaskID(arg string) bool {
	_, err := uuid.Parse(arg)
	return err == nil
}
*/
